{"ast":null,"code":"// Load modules\nvar Any = require('./any');\n\nvar Cast = require('./cast');\n\nvar Errors = require('./errors');\n\nvar Hoek = require('hoek'); // Declare internals\n\n\nvar internals = {};\n\ninternals.fastSplice = function (arr, i) {\n  var il = arr.length;\n  var pos = i;\n\n  while (pos < il) {\n    arr[pos++] = arr[pos];\n  }\n\n  --arr.length;\n};\n\ninternals.Array = function () {\n  Any.call(this);\n  this._type = 'array';\n  this._inner.items = [];\n  this._inner.ordereds = [];\n  this._inner.inclusions = [];\n  this._inner.exclusions = [];\n  this._inner.requireds = [];\n  this._flags.sparse = false;\n};\n\nHoek.inherits(internals.Array, Any);\n\ninternals.Array.prototype._base = function (value, state, options) {\n  var result = {\n    value: value\n  };\n\n  if (typeof value === 'string' && options.convert) {\n    try {\n      var converted = JSON.parse(value);\n\n      if (Array.isArray(converted)) {\n        result.value = converted;\n      }\n    } catch (e) {}\n  }\n\n  var isArray = Array.isArray(result.value);\n  var wasArray = isArray;\n\n  if (options.convert && this._flags.single && !isArray) {\n    result.value = [result.value];\n    isArray = true;\n  }\n\n  if (!isArray) {\n    result.errors = Errors.create('array.base', null, state, options);\n    return result;\n  }\n\n  if (this._inner.inclusions.length || this._inner.exclusions.length || !this._flags.sparse) {\n    // Clone the array so that we don't modify the original\n    if (wasArray) {\n      result.value = result.value.slice(0);\n    }\n\n    result.errors = internals.checkItems.call(this, result.value, wasArray, state, options);\n\n    if (result.errors && wasArray && options.convert && this._flags.single) {\n      // Attempt a 2nd pass by putting the array inside one.\n      var previousErrors = result.errors;\n      result.value = [result.value];\n      result.errors = internals.checkItems.call(this, result.value, wasArray, state, options);\n\n      if (result.errors) {\n        // Restore previous errors and value since this didn't validate either.\n        result.errors = previousErrors;\n        result.value = result.value[0];\n      }\n    }\n  }\n\n  return result;\n};\n\ninternals.checkItems = function (items, wasArray, state, options) {\n  var errors = [];\n  var errored;\n\n  var requireds = this._inner.requireds.slice();\n\n  var ordereds = this._inner.ordereds.slice();\n\n  var inclusions = this._inner.inclusions.concat(requireds);\n\n  for (var v = 0, vl = items.length; v < vl; ++v) {\n    errored = false;\n    var item = items[v];\n    var isValid = false;\n    var localState = {\n      key: v,\n      path: (state.path ? state.path + '.' : '') + v,\n      parent: items,\n      reference: state.reference\n    };\n    var res; // Sparse\n\n    if (!this._flags.sparse && item === undefined) {\n      errors.push(Errors.create('array.sparse', null, {\n        key: state.key,\n        path: localState.path\n      }, options));\n\n      if (options.abortEarly) {\n        return errors;\n      }\n\n      continue;\n    } // Exclusions\n\n\n    for (var i = 0, il = this._inner.exclusions.length; i < il; ++i) {\n      res = this._inner.exclusions[i]._validate(item, localState, {}); // Not passing options to use defaults\n\n      if (!res.errors) {\n        errors.push(Errors.create(wasArray ? 'array.excludes' : 'array.excludesSingle', {\n          pos: v,\n          value: item\n        }, {\n          key: state.key,\n          path: localState.path\n        }, options));\n        errored = true;\n\n        if (options.abortEarly) {\n          return errors;\n        }\n\n        break;\n      }\n    }\n\n    if (errored) {\n      continue;\n    } // Ordered\n\n\n    if (this._inner.ordereds.length) {\n      if (ordereds.length > 0) {\n        var ordered = ordereds.shift();\n        res = ordered._validate(item, localState, options);\n\n        if (!res.errors) {\n          if (ordered._flags.strip) {\n            internals.fastSplice(items, v);\n            --v;\n            --vl;\n          } else {\n            items[v] = res.value;\n          }\n        } else {\n          errors.push(Errors.create('array.ordered', {\n            pos: v,\n            reason: res.errors,\n            value: item\n          }, {\n            key: state.key,\n            path: localState.path\n          }, options));\n\n          if (options.abortEarly) {\n            return errors;\n          }\n        }\n\n        continue;\n      } else if (!this._inner.items.length) {\n        errors.push(Errors.create('array.orderedLength', {\n          pos: v,\n          limit: this._inner.ordereds.length\n        }, {\n          key: state.key,\n          path: localState.path\n        }, options));\n\n        if (options.abortEarly) {\n          return errors;\n        }\n\n        continue;\n      }\n    } // Requireds\n\n\n    var requiredChecks = [];\n\n    for (i = 0, il = requireds.length; i < il; ++i) {\n      res = requiredChecks[i] = requireds[i]._validate(item, localState, options);\n\n      if (!res.errors) {\n        items[v] = res.value;\n        isValid = true;\n        internals.fastSplice(requireds, i);\n        --i;\n        --il;\n        break;\n      }\n    }\n\n    if (isValid) {\n      continue;\n    } // Inclusions\n\n\n    for (i = 0, il = inclusions.length; i < il; ++i) {\n      var inclusion = inclusions[i]; // Avoid re-running requireds that already didn't match in the previous loop\n\n      var previousCheck = requireds.indexOf(inclusion);\n\n      if (previousCheck !== -1) {\n        res = requiredChecks[previousCheck];\n      } else {\n        res = inclusion._validate(item, localState, options);\n\n        if (!res.errors) {\n          if (inclusion._flags.strip) {\n            internals.fastSplice(items, v);\n            --v;\n            --vl;\n          } else {\n            items[v] = res.value;\n          }\n\n          isValid = true;\n          break;\n        }\n      } // Return the actual error if only one inclusion defined\n\n\n      if (il === 1) {\n        if (options.stripUnknown) {\n          internals.fastSplice(items, v);\n          --v;\n          --vl;\n          isValid = true;\n          break;\n        }\n\n        errors.push(Errors.create(wasArray ? 'array.includesOne' : 'array.includesOneSingle', {\n          pos: v,\n          reason: res.errors,\n          value: item\n        }, {\n          key: state.key,\n          path: localState.path\n        }, options));\n        errored = true;\n\n        if (options.abortEarly) {\n          return errors;\n        }\n\n        break;\n      }\n    }\n\n    if (errored) {\n      continue;\n    }\n\n    if (this._inner.inclusions.length && !isValid) {\n      if (options.stripUnknown) {\n        internals.fastSplice(items, v);\n        --v;\n        --vl;\n        continue;\n      }\n\n      errors.push(Errors.create(wasArray ? 'array.includes' : 'array.includesSingle', {\n        pos: v,\n        value: item\n      }, {\n        key: state.key,\n        path: localState.path\n      }, options));\n\n      if (options.abortEarly) {\n        return errors;\n      }\n    }\n  }\n\n  if (requireds.length) {\n    internals.fillMissedErrors(errors, requireds, state, options);\n  }\n\n  if (ordereds.length) {\n    internals.fillOrderedErrors(errors, ordereds, state, options);\n  }\n\n  return errors.length ? errors : null;\n};\n\ninternals.fillMissedErrors = function (errors, requireds, state, options) {\n  var knownMisses = [];\n  var unknownMisses = 0;\n\n  for (var i = 0, il = requireds.length; i < il; ++i) {\n    var label = Hoek.reach(requireds[i], '_settings.language.label');\n\n    if (label) {\n      knownMisses.push(label);\n    } else {\n      ++unknownMisses;\n    }\n  }\n\n  if (knownMisses.length) {\n    if (unknownMisses) {\n      errors.push(Errors.create('array.includesRequiredBoth', {\n        knownMisses: knownMisses,\n        unknownMisses: unknownMisses\n      }, {\n        key: state.key,\n        path: state.patk\n      }, options));\n    } else {\n      errors.push(Errors.create('array.includesRequiredKnowns', {\n        knownMisses: knownMisses\n      }, {\n        key: state.key,\n        path: state.path\n      }, options));\n    }\n  } else {\n    errors.push(Errors.create('array.includesRequiredUnknowns', {\n      unknownMisses: unknownMisses\n    }, {\n      key: state.key,\n      path: state.path\n    }, options));\n  }\n};\n\ninternals.fillOrderedErrors = function (errors, ordereds, state, options) {\n  var requiredOrdereds = [];\n\n  for (var i = 0, il = ordereds.length; i < il; ++i) {\n    var presence = Hoek.reach(ordereds[i], '_flags.presence');\n\n    if (presence === 'required') {\n      requiredOrdereds.push(ordereds[i]);\n    }\n  }\n\n  if (requiredOrdereds.length) {\n    internals.fillMissedErrors(errors, requiredOrdereds, state, options);\n  }\n};\n\ninternals.Array.prototype.describe = function () {\n  var description = Any.prototype.describe.call(this);\n\n  if (this._inner.ordereds.length) {\n    description.orderedItems = [];\n\n    for (var o = 0, ol = this._inner.ordereds.length; o < ol; ++o) {\n      description.orderedItems.push(this._inner.ordereds[o].describe());\n    }\n  }\n\n  if (this._inner.items.length) {\n    description.items = [];\n\n    for (var i = 0, il = this._inner.items.length; i < il; ++i) {\n      description.items.push(this._inner.items[i].describe());\n    }\n  }\n\n  return description;\n};\n\ninternals.Array.prototype.items = function () {\n  var obj = this.clone();\n  Hoek.flatten(Array.prototype.slice.call(arguments)).forEach(function (type, index) {\n    try {\n      type = Cast.schema(type);\n    } catch (castErr) {\n      if (castErr.hasOwnProperty('path')) {\n        castErr.path = index + '.' + castErr.path;\n      } else {\n        castErr.path = index;\n      }\n\n      castErr.message += '(' + castErr.path + ')';\n      throw castErr;\n    }\n\n    obj._inner.items.push(type);\n\n    if (type._flags.presence === 'required') {\n      obj._inner.requireds.push(type);\n    } else if (type._flags.presence === 'forbidden') {\n      obj._inner.exclusions.push(type.optional());\n    } else {\n      obj._inner.inclusions.push(type);\n    }\n  });\n  return obj;\n};\n\ninternals.Array.prototype.ordered = function () {\n  var obj = this.clone();\n  Hoek.flatten(Array.prototype.slice.call(arguments)).forEach(function (type, index) {\n    try {\n      type = Cast.schema(type);\n    } catch (castErr) {\n      if (castErr.hasOwnProperty('path')) {\n        castErr.path = index + '.' + castErr.path;\n      } else {\n        castErr.path = index;\n      }\n\n      castErr.message += '(' + castErr.path + ')';\n      throw castErr;\n    }\n\n    obj._inner.ordereds.push(type);\n  });\n  return obj;\n};\n\ninternals.Array.prototype.min = function (limit) {\n  Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n  return this._test('min', limit, function (value, state, options) {\n    if (value.length >= limit) {\n      return null;\n    }\n\n    return Errors.create('array.min', {\n      limit: limit,\n      value: value\n    }, state, options);\n  });\n};\n\ninternals.Array.prototype.max = function (limit) {\n  Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n  return this._test('max', limit, function (value, state, options) {\n    if (value.length <= limit) {\n      return null;\n    }\n\n    return Errors.create('array.max', {\n      limit: limit,\n      value: value\n    }, state, options);\n  });\n};\n\ninternals.Array.prototype.length = function (limit) {\n  Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n  return this._test('length', limit, function (value, state, options) {\n    if (value.length === limit) {\n      return null;\n    }\n\n    return Errors.create('array.length', {\n      limit: limit,\n      value: value\n    }, state, options);\n  });\n};\n\ninternals.Array.prototype.unique = function () {\n  return this._test('unique', undefined, function (value, state, options) {\n    var found = {\n      string: {},\n      number: {},\n      undefined: {},\n      boolean: {},\n      object: [],\n      function: []\n    };\n\n    for (var i = 0, il = value.length; i < il; ++i) {\n      var item = value[i];\n      var type = typeof item;\n      var records = found[type]; // All available types are supported, so it's not possible to reach 100% coverage without ignoring this line.\n      // I still want to keep the test for future js versions with new types (eg. Symbol).\n\n      if (\n      /* $lab:coverage:off$ */\n      records\n      /* $lab:coverage:on$ */\n      ) {\n          if (Array.isArray(records)) {\n            for (var r = 0, rl = records.length; r < rl; ++r) {\n              if (Hoek.deepEqual(records[r], item)) {\n                return Errors.create('array.unique', {\n                  pos: i,\n                  value: item\n                }, state, options);\n              }\n            }\n\n            records.push(item);\n          } else {\n            if (records[item]) {\n              return Errors.create('array.unique', {\n                pos: i,\n                value: item\n              }, state, options);\n            }\n\n            records[item] = true;\n          }\n        }\n    }\n  });\n};\n\ninternals.Array.prototype.sparse = function (enabled) {\n  var obj = this.clone();\n  obj._flags.sparse = enabled === undefined ? true : !!enabled;\n  return obj;\n};\n\ninternals.Array.prototype.single = function (enabled) {\n  var obj = this.clone();\n  obj._flags.single = enabled === undefined ? true : !!enabled;\n  return obj;\n};\n\nmodule.exports = new internals.Array();","map":null,"metadata":{},"sourceType":"script"}