{"ast":null,"code":"// Load modules\nvar Net = require('net');\n\nvar Hoek = require('hoek');\n\nvar Isemail = require('isemail');\n\nvar Any = require('./any');\n\nvar Ref = require('./ref');\n\nvar JoiDate = require('./date');\n\nvar Errors = require('./errors');\n\nvar Uri = require('./string/uri');\n\nvar Ip = require('./string/ip'); // Declare internals\n\n\nvar internals = {\n  uriRegex: Uri.createUriRegex(),\n  ipRegex: Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], 'optional')\n};\n\ninternals.String = function () {\n  Any.call(this);\n  this._type = 'string';\n\n  this._invalids.add('');\n};\n\nHoek.inherits(internals.String, Any);\n\ninternals.compare = function (type, compare) {\n  return function (limit, encoding) {\n    var isRef = Ref.isRef(limit);\n    Hoek.assert(Hoek.isInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');\n    Hoek.assert(!encoding || Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);\n    return this._test(type, limit, function (value, state, options) {\n      var compareTo;\n\n      if (isRef) {\n        compareTo = limit(state.parent, options);\n\n        if (!Hoek.isInteger(compareTo)) {\n          return Errors.create('string.ref', {\n            ref: limit.key\n          }, state, options);\n        }\n      } else {\n        compareTo = limit;\n      }\n\n      if (compare(value, compareTo, encoding)) {\n        return null;\n      }\n\n      return Errors.create('string.' + type, {\n        limit: compareTo,\n        value: value,\n        encoding: encoding\n      }, state, options);\n    });\n  };\n};\n\ninternals.String.prototype._base = function (value, state, options) {\n  if (typeof value === 'string' && options.convert) {\n    if (this._flags.case) {\n      value = this._flags.case === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase();\n    }\n\n    if (this._flags.trim) {\n      value = value.trim();\n    }\n\n    if (this._inner.replacements) {\n      for (var r = 0, rl = this._inner.replacements.length; r < rl; ++r) {\n        var replacement = this._inner.replacements[r];\n        value = value.replace(replacement.pattern, replacement.replacement);\n      }\n    }\n  }\n\n  return {\n    value: value,\n    errors: typeof value === 'string' ? null : Errors.create('string.base', {\n      value: value\n    }, state, options)\n  };\n};\n\ninternals.String.prototype.insensitive = function () {\n  var obj = this.clone();\n  obj._flags.insensitive = true;\n  return obj;\n};\n\ninternals.String.prototype.min = internals.compare('min', function (value, limit, encoding) {\n  var length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n  return length >= limit;\n});\ninternals.String.prototype.max = internals.compare('max', function (value, limit, encoding) {\n  var length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n  return length <= limit;\n});\n\ninternals.String.prototype.creditCard = function () {\n  return this._test('creditCard', undefined, function (value, state, options) {\n    var i = value.length;\n    var sum = 0;\n    var mul = 1;\n    var char;\n\n    while (i--) {\n      char = value.charAt(i) * mul;\n      sum += char - (char > 9) * 9;\n      mul ^= 3;\n    }\n\n    var check = sum % 10 === 0 && sum > 0;\n    return check ? null : Errors.create('string.creditCard', {\n      value: value\n    }, state, options);\n  });\n};\n\ninternals.String.prototype.length = internals.compare('length', function (value, limit, encoding) {\n  var length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n  return length === limit;\n});\n\ninternals.String.prototype.regex = function (pattern, name) {\n  Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n  pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined); // Future version should break this and forbid unsupported regex flags\n\n  return this._test('regex', pattern, function (value, state, options) {\n    if (pattern.test(value)) {\n      return null;\n    }\n\n    return Errors.create(name ? 'string.regex.name' : 'string.regex.base', {\n      name: name,\n      pattern: pattern,\n      value: value\n    }, state, options);\n  });\n};\n\ninternals.String.prototype.alphanum = function () {\n  return this._test('alphanum', undefined, function (value, state, options) {\n    if (/^[a-zA-Z0-9]+$/.test(value)) {\n      return null;\n    }\n\n    return Errors.create('string.alphanum', {\n      value: value\n    }, state, options);\n  });\n};\n\ninternals.String.prototype.token = function () {\n  return this._test('token', undefined, function (value, state, options) {\n    if (/^\\w+$/.test(value)) {\n      return null;\n    }\n\n    return Errors.create('string.token', {\n      value: value\n    }, state, options);\n  });\n};\n\ninternals.String.prototype.email = function (isEmailOptions) {\n  if (isEmailOptions) {\n    Hoek.assert(typeof isEmailOptions === 'object', 'email options must be an object');\n    Hoek.assert(typeof isEmailOptions.checkDNS === 'undefined', 'checkDNS option is not supported');\n    Hoek.assert(typeof isEmailOptions.tldWhitelist === 'undefined' || typeof isEmailOptions.tldWhitelist === 'object', 'tldWhitelist must be an array or object');\n    Hoek.assert(typeof isEmailOptions.minDomainAtoms === 'undefined' || Hoek.isInteger(isEmailOptions.minDomainAtoms) && isEmailOptions.minDomainAtoms > 0, 'minDomainAtoms must be a positive integer');\n    Hoek.assert(typeof isEmailOptions.errorLevel === 'undefined' || typeof isEmailOptions.errorLevel === 'boolean' || Hoek.isInteger(isEmailOptions.errorLevel) && isEmailOptions.errorLevel >= 0, 'errorLevel must be a non-negative integer or boolean');\n  }\n\n  return this._test('email', isEmailOptions, function (value, state, options) {\n    try {\n      var result = Isemail(value, isEmailOptions);\n\n      if (result === true || result === 0) {\n        return null;\n      }\n    } catch (e) {}\n\n    return Errors.create('string.email', {\n      value: value\n    }, state, options);\n  });\n};\n\ninternals.String.prototype.ip = function (ipOptions) {\n  var regex = internals.ipRegex;\n  ipOptions = ipOptions || {};\n  Hoek.assert(typeof ipOptions === 'object', 'options must be an object');\n\n  if (ipOptions.cidr) {\n    Hoek.assert(typeof ipOptions.cidr === 'string', 'cidr must be a string');\n    ipOptions.cidr = ipOptions.cidr.toLowerCase();\n    Hoek.assert(ipOptions.cidr in Ip.cidrs, 'cidr must be one of ' + Object.keys(Ip.cidrs).join(', ')); // If we only received a `cidr` setting, create a regex for it. But we don't need to create one if `cidr` is \"optional\" since that is the default\n\n    if (!ipOptions.version && ipOptions.cidr !== 'optional') {\n      regex = Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], ipOptions.cidr);\n    }\n  } else {\n    // Set our default cidr strategy\n    ipOptions.cidr = 'optional';\n  }\n\n  if (ipOptions.version) {\n    if (!Array.isArray(ipOptions.version)) {\n      ipOptions.version = [ipOptions.version];\n    }\n\n    Hoek.assert(ipOptions.version.length >= 1, 'version must have at least 1 version specified');\n    var versions = [];\n\n    for (var i = 0, il = ipOptions.version.length; i < il; ++i) {\n      var version = ipOptions.version[i];\n      Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n      version = version.toLowerCase();\n      Hoek.assert(Ip.versions[version], 'version at position ' + i + ' must be one of ' + Object.keys(Ip.versions).join(', '));\n      versions.push(version);\n    } // Make sure we have a set of versions\n\n\n    versions = Hoek.unique(versions);\n    regex = Ip.createIpRegex(versions, ipOptions.cidr);\n  }\n\n  return this._test('ip', ipOptions, function (value, state, options) {\n    if (regex.test(value)) {\n      return null;\n    }\n\n    if (versions) {\n      return Errors.create('string.ipVersion', {\n        value: value,\n        cidr: ipOptions.cidr,\n        version: versions\n      }, state, options);\n    }\n\n    return Errors.create('string.ip', {\n      value: value,\n      cidr: ipOptions.cidr\n    }, state, options);\n  });\n};\n\ninternals.String.prototype.uri = function (uriOptions) {\n  var customScheme = '',\n      regex = internals.uriRegex;\n\n  if (uriOptions) {\n    Hoek.assert(typeof uriOptions === 'object', 'options must be an object');\n\n    if (uriOptions.scheme) {\n      Hoek.assert(uriOptions.scheme instanceof RegExp || typeof uriOptions.scheme === 'string' || Array.isArray(uriOptions.scheme), 'scheme must be a RegExp, String, or Array');\n\n      if (!Array.isArray(uriOptions.scheme)) {\n        uriOptions.scheme = [uriOptions.scheme];\n      }\n\n      Hoek.assert(uriOptions.scheme.length >= 1, 'scheme must have at least 1 scheme specified'); // Flatten the array into a string to be used to match the schemes.\n\n      for (var i = 0, il = uriOptions.scheme.length; i < il; ++i) {\n        var scheme = uriOptions.scheme[i];\n        Hoek.assert(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String'); // Add OR separators if a value already exists\n\n        customScheme += customScheme ? '|' : ''; // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don't escape their pattern unknowingly.\n\n        if (scheme instanceof RegExp) {\n          customScheme += scheme.source;\n        } else {\n          Hoek.assert(/[a-zA-Z][a-zA-Z0-9+-\\.]*/.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');\n          customScheme += Hoek.escapeRegex(scheme);\n        }\n      }\n    }\n  }\n\n  if (customScheme) {\n    regex = Uri.createUriRegex(customScheme);\n  }\n\n  return this._test('uri', uriOptions, function (value, state, options) {\n    if (regex.test(value)) {\n      return null;\n    }\n\n    if (customScheme) {\n      return Errors.create('string.uriCustomScheme', {\n        scheme: customScheme,\n        value: value\n      }, state, options);\n    }\n\n    return Errors.create('string.uri', {\n      value: value\n    }, state, options);\n  });\n};\n\ninternals.String.prototype.isoDate = function () {\n  return this._test('isoDate', undefined, function (value, state, options) {\n    if (JoiDate._isIsoDate(value)) {\n      return null;\n    }\n\n    return Errors.create('string.isoDate', {\n      value: value\n    }, state, options);\n  });\n};\n\ninternals.String.prototype.guid = function () {\n  var regex = /^[A-F0-9]{8}(?:-?[A-F0-9]{4}){3}-?[A-F0-9]{12}$/i;\n  var regex2 = /^\\{[A-F0-9]{8}(?:-?[A-F0-9]{4}){3}-?[A-F0-9]{12}\\}$/i;\n  return this._test('guid', undefined, function (value, state, options) {\n    if (regex.test(value) || regex2.test(value)) {\n      return null;\n    }\n\n    return Errors.create('string.guid', {\n      value: value\n    }, state, options);\n  });\n};\n\ninternals.String.prototype.hex = function () {\n  var regex = /^[a-f0-9]+$/i;\n  return this._test('hex', regex, function (value, state, options) {\n    if (regex.test(value)) {\n      return null;\n    }\n\n    return Errors.create('string.hex', {\n      value: value\n    }, state, options);\n  });\n};\n\ninternals.String.prototype.hostname = function () {\n  var regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$/;\n  return this._test('hostname', undefined, function (value, state, options) {\n    if (value.length <= 255 && regex.test(value) || Net.isIPv6(value)) {\n      return null;\n    }\n\n    return Errors.create('string.hostname', {\n      value: value\n    }, state, options);\n  });\n};\n\ninternals.String.prototype.lowercase = function () {\n  var obj = this._test('lowercase', undefined, function (value, state, options) {\n    if (options.convert || value === value.toLocaleLowerCase()) {\n      return null;\n    }\n\n    return Errors.create('string.lowercase', {\n      value: value\n    }, state, options);\n  });\n\n  obj._flags.case = 'lower';\n  return obj;\n};\n\ninternals.String.prototype.uppercase = function () {\n  var obj = this._test('uppercase', undefined, function (value, state, options) {\n    if (options.convert || value === value.toLocaleUpperCase()) {\n      return null;\n    }\n\n    return Errors.create('string.uppercase', {\n      value: value\n    }, state, options);\n  });\n\n  obj._flags.case = 'upper';\n  return obj;\n};\n\ninternals.String.prototype.trim = function () {\n  var obj = this._test('trim', undefined, function (value, state, options) {\n    if (options.convert || value === value.trim()) {\n      return null;\n    }\n\n    return Errors.create('string.trim', {\n      value: value\n    }, state, options);\n  });\n\n  obj._flags.trim = true;\n  return obj;\n};\n\ninternals.String.prototype.replace = function (pattern, replacement) {\n  if (typeof pattern === 'string') {\n    pattern = new RegExp(Hoek.escapeRegex(pattern), 'g');\n  }\n\n  Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n  Hoek.assert(typeof replacement === 'string', 'replacement must be a String'); // This can not be considere a test like trim, we can't \"reject\"\n  // anything from this rule, so just clone the current object\n\n  var obj = this.clone();\n\n  if (!obj._inner.replacements) {\n    obj._inner.replacements = [];\n  }\n\n  obj._inner.replacements.push({\n    pattern: pattern,\n    replacement: replacement\n  });\n\n  return obj;\n};\n\nmodule.exports = new internals.String();","map":null,"metadata":{},"sourceType":"script"}