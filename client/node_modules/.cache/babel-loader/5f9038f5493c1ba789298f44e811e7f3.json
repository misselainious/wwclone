{"ast":null,"code":"var internals = {\n  rfc3986: {}\n};\n/**\n * elements separated by forward slash (\"/\") are alternatives.\n */\n\nvar or = '|';\n/**\n * DIGIT = %x30-39 ; 0-9\n */\n\nvar digit = '0-9';\nvar digitOnly = '[' + digit + ']';\n/**\n * ALPHA = %x41-5A / %x61-7A   ; A-Z / a-z\n */\n\nvar alpha = 'a-zA-Z';\nvar alphaOnly = '[' + alpha + ']';\n/**\n * cidr       = DIGIT                ; 0-9\n *            / %x31-32 DIGIT         ; 10-29\n *            / \"3\" %x30-32           ; 30-32\n */\n\ninternals.rfc3986.cidr = digitOnly + or + '[1-2]' + digitOnly + or + '3' + '[0-2]';\n/**\n * HEXDIG = DIGIT / \"A\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\"\n */\n\nvar hexDigit = digit + 'A-Fa-f',\n    hexDigitOnly = '[' + hexDigit + ']';\n/**\n * unreserved = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n */\n\nvar unreserved = alpha + digit + '-\\\\._~';\n/**\n * sub-delims = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n */\n\nvar subDelims = '!\\\\$&\\'\\\\(\\\\)\\\\*\\\\+,;=';\n/**\n * pct-encoded = \"%\" HEXDIG HEXDIG\n */\n\nvar pctEncoded = '%' + hexDigit;\n/**\n * pchar = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n */\n\nvar pchar = unreserved + pctEncoded + subDelims + ':@';\nvar pcharOnly = '[' + pchar + ']';\n/**\n * Rule to support zero-padded addresses.\n */\n\nvar zeroPad = '0?';\n/**\n * dec-octet   = DIGIT                 ; 0-9\n *            / %x31-39 DIGIT         ; 10-99\n *            / \"1\" 2DIGIT            ; 100-199\n *            / \"2\" %x30-34 DIGIT     ; 200-249\n *            / \"25\" %x30-35          ; 250-255\n */\n\nvar decOctect = '(?:' + zeroPad + zeroPad + digitOnly + or + zeroPad + '[1-9]' + digitOnly + or + '1' + digitOnly + digitOnly + or + '2' + '[0-4]' + digitOnly + or + '25' + '[0-5])';\n/**\n * IPv4address = dec-octet \".\" dec-octet \".\" dec-octet \".\" dec-octet\n */\n\ninternals.rfc3986.IPv4address = '(?:' + decOctect + '\\\\.){3}' + decOctect;\n/**\n * h16 = 1*4HEXDIG ; 16 bits of address represented in hexadecimal\n * ls32 = ( h16 \":\" h16 ) / IPv4address ; least-significant 32 bits of address\n * IPv6address =                            6( h16 \":\" ) ls32\n *             /                       \"::\" 5( h16 \":\" ) ls32\n *             / [               h16 ] \"::\" 4( h16 \":\" ) ls32\n *             / [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n *             / [ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n *             / [ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n *             / [ *4( h16 \":\" ) h16 ] \"::\"              ls32\n *             / [ *5( h16 \":\" ) h16 ] \"::\"              h16\n *             / [ *6( h16 \":\" ) h16 ] \"::\"\n */\n\nvar h16 = hexDigitOnly + '{1,4}';\nvar ls32 = '(?:' + h16 + ':' + h16 + '|' + internals.rfc3986.IPv4address + ')';\nvar IPv6SixHex = '(?:' + h16 + ':){6}' + ls32;\nvar IPv6FiveHex = '::(?:' + h16 + ':){5}' + ls32;\nvar IPv6FourHex = h16 + '::(?:' + h16 + ':){4}' + ls32;\nvar IPv6ThreeHex = '(?:' + h16 + ':){0,1}' + h16 + '::(?:' + h16 + ':){3}' + ls32;\nvar IPv6TwoHex = '(?:' + h16 + ':){0,2}' + h16 + '::(?:' + h16 + ':){2}' + ls32;\nvar IPv6OneHex = '(?:' + h16 + ':){0,3}' + h16 + '::' + h16 + ':' + ls32;\nvar IPv6NoneHex = '(?:' + h16 + ':){0,4}' + h16 + '::' + ls32;\nvar IPv6NoneHex2 = '(?:' + h16 + ':){0,5}' + h16 + '::' + h16;\nvar IPv6NoneHex3 = '(?:' + h16 + ':){0,6}' + h16 + '::';\ninternals.rfc3986.IPv6address = '(?:' + IPv6SixHex + or + IPv6FiveHex + or + IPv6FourHex + or + IPv6ThreeHex + or + IPv6TwoHex + or + IPv6OneHex + or + IPv6NoneHex + or + IPv6NoneHex2 + or + IPv6NoneHex3 + ')';\n/**\n * IPvFuture = \"v\" 1*HEXDIG \".\" 1*( unreserved / sub-delims / \":\" )\n */\n\ninternals.rfc3986.IPvFuture = 'v' + hexDigitOnly + '+\\\\.[' + unreserved + subDelims + ':]+';\n/**\n * scheme = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n */\n\ninternals.rfc3986.scheme = alphaOnly + '[' + alpha + digit + '+-\\\\.]*';\n/**\n * userinfo = *( unreserved / pct-encoded / sub-delims / \":\" )\n */\n\nvar userinfo = '[' + unreserved + pctEncoded + subDelims + ':]*';\n/**\n * IP-literal = \"[\" ( IPv6address / IPvFuture  ) \"]\"\n */\n\nvar IPLiteral = '\\\\[(?:' + internals.rfc3986.IPv6address + or + internals.rfc3986.IPvFuture + ')\\\\]';\n/**\n * reg-name = *( unreserved / pct-encoded / sub-delims )\n */\n\nvar regName = '[' + unreserved + pctEncoded + subDelims + ']{0,255}';\n/**\n * host = IP-literal / IPv4address / reg-name\n */\n\nvar host = '(?:' + IPLiteral + or + internals.rfc3986.IPv4address + or + regName + ')';\n/**\n * port = *DIGIT\n */\n\nvar port = digitOnly + '*';\n/**\n * authority   = [ userinfo \"@\" ] host [ \":\" port ]\n */\n\nvar authority = '(?:' + userinfo + '@)?' + host + '(?::' + port + ')?';\n/**\n * segment       = *pchar\n * segment-nz    = 1*pchar\n * path          = path-abempty    ; begins with \"/\" or is empty\n *               / path-absolute   ; begins with \"/\" but not \"//\"\n *               / path-noscheme   ; begins with a non-colon segment\n *               / path-rootless   ; begins with a segment\n *               / path-empty      ; zero characters\n * path-abempty  = *( \"/\" segment )\n * path-absolute = \"/\" [ segment-nz *( \"/\" segment ) ]\n * path-rootless = segment-nz *( \"/\" segment )\n */\n\nvar segment = pcharOnly + '*';\nvar segmentNz = pcharOnly + '+';\nvar pathAbEmpty = '(?:\\\\/' + segment + ')*';\nvar pathAbsolute = '\\\\/(?:' + segmentNz + pathAbEmpty + ')?';\nvar pathRootless = segmentNz + pathAbEmpty;\n/**\n * hier-part = \"//\" authority path\n */\n\ninternals.rfc3986.hierPart = '(?:\\\\/\\\\/' + authority + pathAbEmpty + or + pathAbsolute + or + pathRootless + ')';\n/**\n * query = *( pchar / \"/\" / \"?\" )\n */\n\ninternals.rfc3986.query = '[' + pchar + '\\\\/\\\\?]*(?=#|$)'; //Finish matching either at the fragment part or end of the line.\n\n/**\n * fragment = *( pchar / \"/\" / \"?\" )\n */\n\ninternals.rfc3986.fragment = '[' + pchar + '\\\\/\\\\?]*';\nmodule.exports = internals.rfc3986;","map":null,"metadata":{},"sourceType":"script"}