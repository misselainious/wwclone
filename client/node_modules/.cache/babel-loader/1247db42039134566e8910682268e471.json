{"ast":null,"code":"// Load modules\nvar Any = require('./any');\n\nvar Ref = require('./ref');\n\nvar Errors = require('./errors');\n\nvar Hoek = require('hoek'); // Declare internals\n\n\nvar internals = {};\n\ninternals.Number = function () {\n  Any.call(this);\n  this._type = 'number';\n\n  this._invalids.add(Infinity);\n\n  this._invalids.add(-Infinity);\n};\n\nHoek.inherits(internals.Number, Any);\n\ninternals.compare = function (type, compare) {\n  return function (limit) {\n    var isRef = Ref.isRef(limit);\n    var isNumber = typeof limit === 'number' && !isNaN(limit);\n    Hoek.assert(isNumber || isRef, 'limit must be a number or reference');\n    return this._test(type, limit, function (value, state, options) {\n      var compareTo;\n\n      if (isRef) {\n        compareTo = limit(state.parent, options);\n\n        if (!(typeof compareTo === 'number' && !isNaN(compareTo))) {\n          return Errors.create('number.ref', {\n            ref: limit.key\n          }, state, options);\n        }\n      } else {\n        compareTo = limit;\n      }\n\n      if (compare(value, compareTo)) {\n        return null;\n      }\n\n      return Errors.create('number.' + type, {\n        limit: compareTo,\n        value: value\n      }, state, options);\n    });\n  };\n};\n\ninternals.Number.prototype._base = function (value, state, options) {\n  var result = {\n    errors: null,\n    value: value\n  };\n\n  if (typeof value === 'string' && options.convert) {\n    var number = parseFloat(value);\n    result.value = isNaN(number) || !isFinite(value) ? NaN : number;\n  }\n\n  var isNumber = typeof result.value === 'number' && !isNaN(result.value);\n\n  if (options.convert && 'precision' in this._flags && isNumber) {\n    // This is conceptually equivalent to using toFixed but it should be much faster\n    var precision = Math.pow(10, this._flags.precision);\n    result.value = Math.round(result.value * precision) / precision;\n  }\n\n  result.errors = isNumber ? null : Errors.create('number.base', null, state, options);\n  return result;\n};\n\ninternals.Number.prototype.min = internals.compare('min', function (value, limit) {\n  return value >= limit;\n});\ninternals.Number.prototype.max = internals.compare('max', function (value, limit) {\n  return value <= limit;\n});\ninternals.Number.prototype.greater = internals.compare('greater', function (value, limit) {\n  return value > limit;\n});\ninternals.Number.prototype.less = internals.compare('less', function (value, limit) {\n  return value < limit;\n});\n\ninternals.Number.prototype.multiple = function (base) {\n  Hoek.assert(Hoek.isInteger(base), 'multiple must be an integer');\n  Hoek.assert(base > 0, 'multiple must be greater than 0');\n  return this._test('multiple', base, function (value, state, options) {\n    if (value % base === 0) {\n      return null;\n    }\n\n    return Errors.create('number.multiple', {\n      multiple: base,\n      value: value\n    }, state, options);\n  });\n};\n\ninternals.Number.prototype.integer = function () {\n  return this._test('integer', undefined, function (value, state, options) {\n    return Hoek.isInteger(value) ? null : Errors.create('number.integer', {\n      value: value\n    }, state, options);\n  });\n};\n\ninternals.Number.prototype.negative = function () {\n  return this._test('negative', undefined, function (value, state, options) {\n    if (value < 0) {\n      return null;\n    }\n\n    return Errors.create('number.negative', {\n      value: value\n    }, state, options);\n  });\n};\n\ninternals.Number.prototype.positive = function () {\n  return this._test('positive', undefined, function (value, state, options) {\n    if (value > 0) {\n      return null;\n    }\n\n    return Errors.create('number.positive', {\n      value: value\n    }, state, options);\n  });\n};\n\ninternals.precisionRx = /(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/;\n\ninternals.Number.prototype.precision = function (limit) {\n  Hoek.assert(Hoek.isInteger(limit), 'limit must be an integer');\n  Hoek.assert(!('precision' in this._flags), 'precision already set');\n\n  var obj = this._test('precision', limit, function (value, state, options) {\n    var places = value.toString().match(internals.precisionRx);\n    var decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);\n\n    if (decimals <= limit) {\n      return null;\n    }\n\n    return Errors.create('number.precision', {\n      limit: limit,\n      value: value\n    }, state, options);\n  });\n\n  obj._flags.precision = limit;\n  return obj;\n};\n\nmodule.exports = new internals.Number();","map":null,"metadata":{},"sourceType":"script"}