{"ast":null,"code":"// Load modules\nvar Hoek = require('hoek');\n\nvar Topo = require('topo');\n\nvar Any = require('./any');\n\nvar Cast = require('./cast');\n\nvar Errors = require('./errors'); // Declare internals\n\n\nvar internals = {};\n\ninternals.Object = function () {\n  Any.call(this);\n  this._type = 'object';\n  this._inner.children = null;\n  this._inner.renames = [];\n  this._inner.dependencies = [];\n  this._inner.patterns = [];\n};\n\nHoek.inherits(internals.Object, Any);\n\ninternals.Object.prototype._base = function (value, state, options) {\n  var item, key, localState, result;\n  var target = value;\n  var errors = [];\n\n  var finish = function finish() {\n    return {\n      value: target,\n      errors: errors.length ? errors : null\n    };\n  };\n\n  if (typeof value === 'string' && options.convert) {\n    try {\n      value = JSON.parse(value);\n    } catch (parseErr) {}\n  }\n\n  var type = this._flags.func ? 'function' : 'object';\n\n  if (!value || typeof value !== type || Array.isArray(value)) {\n    errors.push(Errors.create(type + '.base', null, state, options));\n    return finish();\n  } // Skip if there are no other rules to test\n\n\n  if (!this._inner.renames.length && !this._inner.dependencies.length && !this._inner.children && // null allows any keys\n  !this._inner.patterns.length) {\n    target = value;\n    return finish();\n  } // Ensure target is a local copy (parsed) or shallow copy\n\n\n  if (target === value) {\n    if (type === 'object') {\n      target = Object.create(Object.getPrototypeOf(value));\n    } else {\n      target = function target() {\n        return value.apply(this, arguments);\n      };\n\n      target.prototype = Hoek.clone(value.prototype);\n    }\n\n    var valueKeys = Object.keys(value);\n\n    for (var t = 0, tl = valueKeys.length; t < tl; ++t) {\n      target[valueKeys[t]] = value[valueKeys[t]];\n    }\n  } else {\n    target = value;\n  } // Rename keys\n\n\n  var renamed = {};\n\n  for (var r = 0, rl = this._inner.renames.length; r < rl; ++r) {\n    item = this._inner.renames[r];\n\n    if (item.options.ignoreUndefined && target[item.from] === undefined) {\n      continue;\n    }\n\n    if (!item.options.multiple && renamed[item.to]) {\n      errors.push(Errors.create('object.rename.multiple', {\n        from: item.from,\n        to: item.to\n      }, state, options));\n\n      if (options.abortEarly) {\n        return finish();\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(target, item.to) && !item.options.override && !renamed[item.to]) {\n      errors.push(Errors.create('object.rename.override', {\n        from: item.from,\n        to: item.to\n      }, state, options));\n\n      if (options.abortEarly) {\n        return finish();\n      }\n    }\n\n    if (target[item.from] === undefined) {\n      delete target[item.to];\n    } else {\n      target[item.to] = target[item.from];\n    }\n\n    renamed[item.to] = true;\n\n    if (!item.options.alias) {\n      delete target[item.from];\n    }\n  } // Validate schema\n\n\n  if (!this._inner.children && // null allows any keys\n  !this._inner.patterns.length && !this._inner.dependencies.length) {\n    return finish();\n  }\n\n  var unprocessed = Hoek.mapToObject(Object.keys(target));\n\n  if (this._inner.children) {\n    for (var i = 0, il = this._inner.children.length; i < il; ++i) {\n      var child = this._inner.children[i];\n      key = child.key;\n      item = target[key];\n      delete unprocessed[key];\n      localState = {\n        key: key,\n        path: (state.path || '') + (state.path && key ? '.' : '') + key,\n        parent: target,\n        reference: state.reference\n      };\n      result = child.schema._validate(item, localState, options);\n\n      if (result.errors) {\n        errors.push(Errors.create('object.child', {\n          key: key,\n          reason: result.errors\n        }, localState, options));\n\n        if (options.abortEarly) {\n          return finish();\n        }\n      }\n\n      if (child.schema._flags.strip || result.value === undefined && result.value !== item) {\n        delete target[key];\n      } else if (result.value !== undefined) {\n        target[key] = result.value;\n      }\n    }\n  } // Unknown keys\n\n\n  var unprocessedKeys = Object.keys(unprocessed);\n\n  if (unprocessedKeys.length && this._inner.patterns.length) {\n    for (i = 0, il = unprocessedKeys.length; i < il; ++i) {\n      key = unprocessedKeys[i];\n\n      for (var p = 0, pl = this._inner.patterns.length; p < pl; ++p) {\n        var pattern = this._inner.patterns[p];\n\n        if (pattern.regex.test(key)) {\n          delete unprocessed[key];\n          item = target[key];\n          localState = {\n            key: key,\n            path: (state.path ? state.path + '.' : '') + key,\n            parent: target,\n            reference: state.reference\n          };\n          result = pattern.rule._validate(item, localState, options);\n\n          if (result.errors) {\n            errors.push(Errors.create('object.child', {\n              key: key,\n              reason: result.errors\n            }, localState, options));\n\n            if (options.abortEarly) {\n              return finish();\n            }\n          }\n\n          if (result.value !== undefined) {\n            target[key] = result.value;\n          }\n        }\n      }\n    }\n\n    unprocessedKeys = Object.keys(unprocessed);\n  }\n\n  if ((this._inner.children || this._inner.patterns.length) && unprocessedKeys.length) {\n    if (options.stripUnknown || options.skipFunctions) {\n      for (var k = 0, kl = unprocessedKeys.length; k < kl; ++k) {\n        key = unprocessedKeys[k];\n\n        if (options.stripUnknown) {\n          delete target[key];\n          delete unprocessed[key];\n        } else if (typeof target[key] === 'function') {\n          delete unprocessed[key];\n        }\n      }\n\n      unprocessedKeys = Object.keys(unprocessed);\n    }\n\n    if (unprocessedKeys.length && (this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\n      for (var e = 0, el = unprocessedKeys.length; e < el; ++e) {\n        errors.push(Errors.create('object.allowUnknown', null, {\n          key: unprocessedKeys[e],\n          path: state.path + (state.path ? '.' : '') + unprocessedKeys[e]\n        }, options));\n      }\n    }\n  } // Validate dependencies\n\n\n  for (var d = 0, dl = this._inner.dependencies.length; d < dl; ++d) {\n    var dep = this._inner.dependencies[d];\n    var err = internals[dep.type](dep.key !== null && value[dep.key], dep.peers, target, {\n      key: dep.key,\n      path: (state.path || '') + (dep.key ? '.' + dep.key : '')\n    }, options);\n\n    if (err) {\n      errors.push(err);\n\n      if (options.abortEarly) {\n        return finish();\n      }\n    }\n  }\n\n  return finish();\n};\n\ninternals.Object.prototype._func = function () {\n  var obj = this.clone();\n  obj._flags.func = true;\n  return obj;\n};\n\ninternals.Object.prototype.keys = function (schema) {\n  Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\n  Hoek.assert(!schema || !schema.isJoi, 'Object schema cannot be a joi schema');\n  var obj = this.clone();\n\n  if (!schema) {\n    obj._inner.children = null;\n    return obj;\n  }\n\n  var children = Object.keys(schema);\n\n  if (!children.length) {\n    obj._inner.children = [];\n    return obj;\n  }\n\n  var topo = new Topo();\n  var child;\n\n  if (obj._inner.children) {\n    for (var i = 0, il = obj._inner.children.length; i < il; ++i) {\n      child = obj._inner.children[i]; // Only add the key if we are not going to replace it later\n\n      if (children.indexOf(child.key) === -1) {\n        topo.add(child, {\n          after: child._refs,\n          group: child.key\n        });\n      }\n    }\n  }\n\n  for (var c = 0, cl = children.length; c < cl; ++c) {\n    var key = children[c];\n    child = schema[key];\n\n    try {\n      var cast = Cast.schema(child);\n      topo.add({\n        key: key,\n        schema: cast\n      }, {\n        after: cast._refs,\n        group: key\n      });\n    } catch (castErr) {\n      if (castErr.hasOwnProperty('path')) {\n        castErr.path = key + '.' + castErr.path;\n      } else {\n        castErr.path = key;\n      }\n\n      throw castErr;\n    }\n  }\n\n  obj._inner.children = topo.nodes;\n  return obj;\n};\n\ninternals.Object.prototype.unknown = function (allow) {\n  var obj = this.clone();\n  obj._flags.allowUnknown = allow !== false;\n  return obj;\n};\n\ninternals.Object.prototype.length = function (limit) {\n  Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n  return this._test('length', limit, function (value, state, options) {\n    if (Object.keys(value).length === limit) {\n      return null;\n    }\n\n    return Errors.create('object.length', {\n      limit: limit\n    }, state, options);\n  });\n};\n\ninternals.Object.prototype.min = function (limit) {\n  Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n  return this._test('min', limit, function (value, state, options) {\n    if (Object.keys(value).length >= limit) {\n      return null;\n    }\n\n    return Errors.create('object.min', {\n      limit: limit\n    }, state, options);\n  });\n};\n\ninternals.Object.prototype.max = function (limit) {\n  Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n  return this._test('max', limit, function (value, state, options) {\n    if (Object.keys(value).length <= limit) {\n      return null;\n    }\n\n    return Errors.create('object.max', {\n      limit: limit\n    }, state, options);\n  });\n};\n\ninternals.Object.prototype.pattern = function (pattern, schema) {\n  Hoek.assert(pattern instanceof RegExp, 'Invalid regular expression');\n  Hoek.assert(schema !== undefined, 'Invalid rule');\n  pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined); // Future version should break this and forbid unsupported regex flags\n\n  try {\n    schema = Cast.schema(schema);\n  } catch (castErr) {\n    if (castErr.hasOwnProperty('path')) {\n      castErr.message += '(' + castErr.path + ')';\n    }\n\n    throw castErr;\n  }\n\n  var obj = this.clone();\n\n  obj._inner.patterns.push({\n    regex: pattern,\n    rule: schema\n  });\n\n  return obj;\n};\n\ninternals.Object.prototype.with = function (key, peers) {\n  return this._dependency('with', key, peers);\n};\n\ninternals.Object.prototype.without = function (key, peers) {\n  return this._dependency('without', key, peers);\n};\n\ninternals.Object.prototype.xor = function () {\n  var peers = Hoek.flatten(Array.prototype.slice.call(arguments));\n  return this._dependency('xor', null, peers);\n};\n\ninternals.Object.prototype.or = function () {\n  var peers = Hoek.flatten(Array.prototype.slice.call(arguments));\n  return this._dependency('or', null, peers);\n};\n\ninternals.Object.prototype.and = function () {\n  var peers = Hoek.flatten(Array.prototype.slice.call(arguments));\n  return this._dependency('and', null, peers);\n};\n\ninternals.Object.prototype.nand = function () {\n  var peers = Hoek.flatten(Array.prototype.slice.call(arguments));\n  return this._dependency('nand', null, peers);\n};\n\ninternals.Object.prototype.requiredKeys = function (children) {\n  children = Hoek.flatten(Array.prototype.slice.call(arguments));\n  return this.applyFunctionToChildren(children, 'required');\n};\n\ninternals.Object.prototype.optionalKeys = function (children) {\n  children = Hoek.flatten(Array.prototype.slice.call(arguments));\n  return this.applyFunctionToChildren(children, 'optional');\n};\n\ninternals.renameDefaults = {\n  alias: false,\n  // Keep old value in place\n  multiple: false,\n  // Allow renaming multiple keys into the same target\n  override: false // Overrides an existing key\n\n};\n\ninternals.Object.prototype.rename = function (from, to, options) {\n  Hoek.assert(typeof from === 'string', 'Rename missing the from argument');\n  Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\n  Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\n\n  for (var i = 0, il = this._inner.renames.length; i < il; ++i) {\n    Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\n  }\n\n  var obj = this.clone();\n\n  obj._inner.renames.push({\n    from: from,\n    to: to,\n    options: Hoek.applyToDefaults(internals.renameDefaults, options || {})\n  });\n\n  return obj;\n};\n\ninternals.groupChildren = function (children) {\n  children.sort();\n  var grouped = {};\n\n  for (var c = 0, lc = children.length; c < lc; c++) {\n    var child = children[c];\n    Hoek.assert(typeof child === 'string', 'children must be strings');\n    var group = child.split('.')[0];\n    var childGroup = grouped[group] = grouped[group] || [];\n    childGroup.push(child.substring(group.length + 1));\n  }\n\n  return grouped;\n};\n\ninternals.Object.prototype.applyFunctionToChildren = function (children, fn, args, root) {\n  children = [].concat(children);\n  Hoek.assert(children.length > 0, 'expected at least one children');\n  var groupedChildren = internals.groupChildren(children);\n  var obj;\n\n  if ('' in groupedChildren) {\n    obj = this[fn].apply(this, args);\n    delete groupedChildren[''];\n  } else {\n    obj = this.clone();\n  }\n\n  if (obj._inner.children) {\n    root = root ? root + '.' : '';\n\n    for (var i = 0, il = obj._inner.children.length; i < il; ++i) {\n      var child = obj._inner.children[i];\n      var group = groupedChildren[child.key];\n\n      if (group) {\n        obj._inner.children[i] = {\n          key: child.key,\n          _refs: child._refs,\n          schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\n        };\n        delete groupedChildren[child.key];\n      }\n    }\n  }\n\n  var remaining = Object.keys(groupedChildren);\n  Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\n  return obj;\n};\n\ninternals.Object.prototype._dependency = function (type, key, peers) {\n  peers = [].concat(peers);\n\n  for (var i = 0, li = peers.length; i < li; i++) {\n    Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\n  }\n\n  var obj = this.clone();\n\n  obj._inner.dependencies.push({\n    type: type,\n    key: key,\n    peers: peers\n  });\n\n  return obj;\n};\n\ninternals.with = function (value, peers, parent, state, options) {\n  if (value === undefined) {\n    return null;\n  }\n\n  for (var i = 0, il = peers.length; i < il; ++i) {\n    var peer = peers[i];\n\n    if (!Object.prototype.hasOwnProperty.call(parent, peer) || parent[peer] === undefined) {\n      return Errors.create('object.with', {\n        peer: peer\n      }, state, options);\n    }\n  }\n\n  return null;\n};\n\ninternals.without = function (value, peers, parent, state, options) {\n  if (value === undefined) {\n    return null;\n  }\n\n  for (var i = 0, il = peers.length; i < il; ++i) {\n    var peer = peers[i];\n\n    if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== undefined) {\n      return Errors.create('object.without', {\n        peer: peer\n      }, state, options);\n    }\n  }\n\n  return null;\n};\n\ninternals.xor = function (value, peers, parent, state, options) {\n  var present = [];\n\n  for (var i = 0, il = peers.length; i < il; ++i) {\n    var peer = peers[i];\n\n    if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== undefined) {\n      present.push(peer);\n    }\n  }\n\n  if (present.length === 1) {\n    return null;\n  }\n\n  if (present.length === 0) {\n    return Errors.create('object.missing', {\n      peers: peers\n    }, state, options);\n  }\n\n  return Errors.create('object.xor', {\n    peers: peers\n  }, state, options);\n};\n\ninternals.or = function (value, peers, parent, state, options) {\n  for (var i = 0, il = peers.length; i < il; ++i) {\n    var peer = peers[i];\n\n    if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== undefined) {\n      return null;\n    }\n  }\n\n  return Errors.create('object.missing', {\n    peers: peers\n  }, state, options);\n};\n\ninternals.and = function (value, peers, parent, state, options) {\n  var missing = [];\n  var present = [];\n  var count = peers.length;\n\n  for (var i = 0; i < count; ++i) {\n    var peer = peers[i];\n\n    if (!Object.prototype.hasOwnProperty.call(parent, peer) || parent[peer] === undefined) {\n      missing.push(peer);\n    } else {\n      present.push(peer);\n    }\n  }\n\n  var aon = missing.length === count || present.length === count;\n  return !aon ? Errors.create('object.and', {\n    present: present,\n    missing: missing\n  }, state, options) : null;\n};\n\ninternals.nand = function (value, peers, parent, state, options) {\n  var present = [];\n\n  for (var i = 0, il = peers.length; i < il; ++i) {\n    var peer = peers[i];\n\n    if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== undefined) {\n      present.push(peer);\n    }\n  }\n\n  var values = Hoek.clone(peers);\n  var main = values.splice(0, 1)[0];\n  var allPresent = present.length === peers.length;\n  return allPresent ? Errors.create('object.nand', {\n    main: main,\n    peers: values\n  }, state, options) : null;\n};\n\ninternals.Object.prototype.describe = function (shallow) {\n  var description = Any.prototype.describe.call(this);\n\n  if (this._inner.children && !shallow) {\n    description.children = {};\n\n    for (var i = 0, il = this._inner.children.length; i < il; ++i) {\n      var child = this._inner.children[i];\n      description.children[child.key] = child.schema.describe();\n    }\n  }\n\n  if (this._inner.dependencies.length) {\n    description.dependencies = Hoek.clone(this._inner.dependencies);\n  }\n\n  if (this._inner.patterns.length) {\n    description.patterns = [];\n\n    for (var p = 0, pl = this._inner.patterns.length; p < pl; ++p) {\n      var pattern = this._inner.patterns[p];\n      description.patterns.push({\n        regex: pattern.regex.toString(),\n        rule: pattern.rule.describe()\n      });\n    }\n  }\n\n  return description;\n};\n\ninternals.Object.prototype.assert = function (ref, schema, message) {\n  ref = Cast.ref(ref);\n  Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\n  message = message || 'pass the assertion test';\n  var cast;\n\n  try {\n    cast = Cast.schema(schema);\n  } catch (castErr) {\n    if (castErr.hasOwnProperty('path')) {\n      castErr.message += '(' + castErr.path + ')';\n    }\n\n    throw castErr;\n  }\n\n  var key = ref.path[ref.path.length - 1];\n  var path = ref.path.join('.');\n  return this._test('assert', {\n    cast: cast,\n    ref: ref\n  }, function (value, state, options) {\n    var result = cast._validate(ref(value), null, options, value);\n\n    if (!result.errors) {\n      return null;\n    }\n\n    var localState = Hoek.merge({}, state);\n    localState.key = key;\n    localState.path = path;\n    return Errors.create('object.assert', {\n      ref: localState.path,\n      message: message\n    }, localState, options);\n  });\n};\n\ninternals.Object.prototype.type = function (constructor, name) {\n  Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\n  name = name || constructor.name;\n  return this._test('type', name, function (value, state, options) {\n    if (value instanceof constructor) {\n      return null;\n    }\n\n    return Errors.create('object.type', {\n      type: name\n    }, state, options);\n  });\n};\n\nmodule.exports = new internals.Object();","map":null,"metadata":{},"sourceType":"script"}