{"ast":null,"code":"// Load modules\nvar Hoek = require('hoek');\n\nvar Language = require('./language'); // Declare internals\n\n\nvar internals = {};\n\ninternals.stringify = function (value, wrapArrays) {\n  var type = typeof value;\n\n  if (value === null) {\n    return 'null';\n  }\n\n  if (type === 'string') {\n    return value;\n  }\n\n  if (value instanceof internals.Err || type === 'function') {\n    return value.toString();\n  }\n\n  if (type === 'object') {\n    if (Array.isArray(value)) {\n      var partial = '';\n\n      for (var i = 0, il = value.length; i < il; ++i) {\n        partial += (partial.length ? ', ' : '') + internals.stringify(value[i], wrapArrays);\n      }\n\n      return wrapArrays ? '[' + partial + ']' : partial;\n    }\n\n    return value.toString();\n  }\n\n  return JSON.stringify(value);\n};\n\ninternals.Err = function (type, context, state, options) {\n  this.type = type;\n  this.context = context || {};\n  this.context.key = state.key;\n  this.path = state.path;\n  this.options = options;\n};\n\ninternals.Err.prototype.toString = function () {\n  var self = this;\n  var localized = this.options.language;\n\n  if (localized.label) {\n    this.context.key = localized.label;\n  } else if (this.context.key === '' || this.context.key === null) {\n    this.context.key = localized.root || Language.errors.root;\n  }\n\n  var format = Hoek.reach(localized, this.type) || Hoek.reach(Language.errors, this.type);\n  var hasKey = /\\{\\{\\!?key\\}\\}/.test(format);\n  var skipKey = format.length > 2 && format[0] === '!' && format[1] === '!';\n\n  if (skipKey) {\n    format = format.slice(2);\n  }\n\n  if (!hasKey && !skipKey) {\n    format = (Hoek.reach(localized, 'key') || Hoek.reach(Language.errors, 'key')) + format;\n  }\n\n  var wrapArrays = Hoek.reach(localized, 'messages.wrapArrays');\n\n  if (typeof wrapArrays !== 'boolean') {\n    wrapArrays = Language.errors.messages.wrapArrays;\n  }\n\n  var message = format.replace(/\\{\\{(\\!?)([^}]+)\\}\\}/g, function ($0, isSecure, name) {\n    var value = Hoek.reach(self.context, name);\n    var normalized = internals.stringify(value, wrapArrays);\n    return isSecure ? Hoek.escapeHtml(normalized) : normalized;\n  });\n  return message;\n};\n\nexports.create = function (type, context, state, options) {\n  return new internals.Err(type, context, state, options);\n};\n\nexports.process = function (errors, object) {\n  if (!errors || !errors.length) {\n    return null;\n  } // Construct error\n\n\n  var message = '';\n  var details = [];\n\n  var processErrors = function processErrors(localErrors, parent) {\n    for (var i = 0, il = localErrors.length; i < il; ++i) {\n      var item = localErrors[i];\n      var detail = {\n        message: item.toString(),\n        path: internals.getPath(item),\n        type: item.type,\n        context: item.context\n      };\n\n      if (!parent) {\n        message += (message ? '. ' : '') + detail.message;\n      } // Do not push intermediate errors, we're only interested in leafs\n\n\n      if (item.context.reason && item.context.reason.length) {\n        processErrors(item.context.reason, item.path);\n      } else {\n        details.push(detail);\n      }\n    }\n  };\n\n  processErrors(errors);\n  var error = new Error(message);\n  error.name = 'ValidationError';\n  error.details = details;\n  error._object = object;\n  error.annotate = internals.annotate;\n  return error;\n};\n\ninternals.getPath = function (item) {\n  var recursePath = function recursePath(it) {\n    var reachedItem = Hoek.reach(it, 'context.reason.0');\n\n    if (reachedItem && reachedItem.context) {\n      return recursePath(reachedItem);\n    }\n\n    return it.path;\n  };\n\n  return recursePath(item) || item.context.key;\n}; // Inspired by json-stringify-safe\n\n\ninternals.safeStringify = function (obj, spaces) {\n  return JSON.stringify(obj, internals.serializer(), spaces);\n};\n\ninternals.serializer = function () {\n  var cycleReplacer = function cycleReplacer(key, value) {\n    if (stack[0] === value) {\n      return '[Circular ~]';\n    }\n\n    return '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';\n  };\n\n  var keys = [],\n      stack = [];\n  return function (key, value) {\n    if (stack.length > 0) {\n      var thisPos = stack.indexOf(this);\n\n      if (~thisPos) {\n        stack.length = thisPos + 1;\n        keys.length = thisPos + 1;\n        keys[thisPos] = key;\n      } else {\n        stack.push(this);\n        keys.push(key);\n      }\n\n      if (~stack.indexOf(value)) {\n        value = cycleReplacer.call(this, key, value);\n      }\n    } else {\n      stack.push(value);\n    }\n\n    if (Array.isArray(value) && value.placeholders) {\n      var placeholders = value.placeholders;\n      var arrWithPlaceholders = [];\n\n      for (var i = 0, il = value.length; i < il; ++i) {\n        if (placeholders[i]) {\n          arrWithPlaceholders.push(placeholders[i]);\n        }\n\n        arrWithPlaceholders.push(value[i]);\n      }\n\n      value = arrWithPlaceholders;\n    }\n\n    return value;\n  };\n};\n\ninternals.annotate = function () {\n  var obj = Hoek.clone(this._object || {});\n  var lookup = {};\n  var el = this.details.length;\n\n  for (var e = el - 1; e >= 0; --e) {\n    // Reverse order to process deepest child first\n    var pos = el - e;\n    var error = this.details[e];\n    var path = error.path.split('.');\n    var ref = obj;\n\n    for (var i = 0, il = path.length; i < il && ref; ++i) {\n      var seg = path[i];\n\n      if (i + 1 < il) {\n        ref = ref[seg];\n      } else {\n        var value = ref[seg];\n\n        if (Array.isArray(ref)) {\n          var arrayLabel = '_$idx$_' + (e + 1) + '_$end$_';\n\n          if (!ref.placeholders) {\n            ref.placeholders = {};\n          }\n\n          if (ref.placeholders[seg]) {\n            ref.placeholders[seg] = ref.placeholders[seg].replace('_$end$_', ', ' + (e + 1) + '_$end$_');\n          } else {\n            ref.placeholders[seg] = arrayLabel;\n          }\n        } else {\n          if (value !== undefined) {\n            delete ref[seg];\n            var objectLabel = seg + '_$key$_' + pos + '_$end$_';\n            ref[objectLabel] = value;\n            lookup[error.path] = objectLabel;\n          } else if (lookup[error.path]) {\n            var replacement = lookup[error.path];\n            var appended = replacement.replace('_$end$_', ', ' + pos + '_$end$_');\n            ref[appended] = ref[replacement];\n            lookup[error.path] = appended;\n            delete ref[replacement];\n          } else {\n            ref['_$miss$_' + seg + '|' + pos + '_$end$_'] = '__missing__';\n          }\n        }\n      }\n    }\n  }\n\n  var message = internals.safeStringify(obj, 2).replace(/_\\$key\\$_([, \\d]+)_\\$end\\$_\\\"/g, function ($0, $1) {\n    return \"\\\" \\x1B[31m[\" + $1 + \"]\\x1B[0m\";\n  }).replace(/\\\"_\\$miss\\$_([^\\|]+)\\|(\\d+)_\\$end\\$_\\\"\\: \\\"__missing__\\\"/g, function ($0, $1, $2) {\n    return \"\\x1B[41m\\\"\" + $1 + \"\\\"\\x1B[0m\\x1B[31m [\" + $2 + \"]: -- missing --\\x1B[0m\";\n  }).replace(/\\s*\\\"_\\$idx\\$_([, \\d]+)_\\$end\\$_\\\",?\\n(.*)/g, function ($0, $1, $2) {\n    return '\\n' + $2 + \" \\x1B[31m[\" + $1 + \"]\\x1B[0m\";\n  });\n  message += \"\\n\\x1B[31m\";\n\n  for (e = 0; e < el; ++e) {\n    message += '\\n[' + (e + 1) + '] ' + this.details[e].message;\n  }\n\n  message += \"\\x1B[0m\";\n  return message;\n};","map":null,"metadata":{},"sourceType":"script"}