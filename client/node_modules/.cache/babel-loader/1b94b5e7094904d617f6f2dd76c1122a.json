{"ast":null,"code":"// Load modules\nvar Hoek = require('hoek'); // Declare internals\n\n\nvar internals = {};\n\nexports = module.exports = internals.Topo = function () {\n  this._items = [];\n  this.nodes = [];\n};\n\ninternals.Topo.prototype.add = function (nodes, options) {\n  var self = this;\n  options = options || {}; // Validate rules\n\n  var before = [].concat(options.before || []);\n  var after = [].concat(options.after || []);\n  var group = options.group || '?';\n  var sort = options.sort || 0; // Used for merging only\n\n  Hoek.assert(before.indexOf(group) === -1, 'Item cannot come before itself:', group);\n  Hoek.assert(before.indexOf('?') === -1, 'Item cannot come before unassociated items');\n  Hoek.assert(after.indexOf(group) === -1, 'Item cannot come after itself:', group);\n  Hoek.assert(after.indexOf('?') === -1, 'Item cannot come after unassociated items');\n  [].concat(nodes).forEach(function (node, i) {\n    var item = {\n      seq: self._items.length,\n      sort: sort,\n      before: before,\n      after: after,\n      group: group,\n      node: node\n    };\n\n    self._items.push(item);\n  }); // Insert event\n\n  var error = this._sort();\n\n  Hoek.assert(!error, 'item', group !== '?' ? 'added into group ' + group : '', 'created a dependencies error');\n  return this.nodes;\n};\n\ninternals.Topo.prototype.merge = function (others) {\n  others = [].concat(others);\n\n  for (var o = 0, ol = others.length; o < ol; ++o) {\n    var other = others[o];\n\n    if (other) {\n      for (var i = 0, il = other._items.length; i < il; ++i) {\n        var item = Hoek.shallow(other._items[i]);\n\n        this._items.push(item);\n      }\n    }\n  } // Sort items\n\n\n  this._items.sort(internals.mergeSort);\n\n  for (i = 0, il = this._items.length; i < il; ++i) {\n    this._items[i].seq = i;\n  }\n\n  var error = this._sort();\n\n  Hoek.assert(!error, 'merge created a dependencies error');\n  return this.nodes;\n};\n\ninternals.mergeSort = function (a, b) {\n  return a.sort === b.sort ? 0 : a.sort < b.sort ? -1 : 1;\n};\n\ninternals.Topo.prototype._sort = function () {\n  // Construct graph\n  var groups = {};\n  var graph = {};\n  var graphAfters = {};\n\n  for (var i = 0, il = this._items.length; i < il; ++i) {\n    var item = this._items[i];\n    var seq = item.seq; // Unique across all items\n\n    var group = item.group; // Determine Groups\n\n    groups[group] = groups[group] || [];\n    groups[group].push(seq); // Build intermediary graph using 'before'\n\n    graph[seq] = item.before; // Build second intermediary graph with 'after'\n\n    var after = item.after;\n\n    for (var j = 0, jl = after.length; j < jl; ++j) {\n      graphAfters[after[j]] = (graphAfters[after[j]] || []).concat(seq);\n    }\n  } // Expand intermediary graph\n\n\n  var graphNodes = Object.keys(graph);\n\n  for (i = 0, il = graphNodes.length; i < il; ++i) {\n    var node = graphNodes[i];\n    var expandedGroups = [];\n    var graphNodeItems = Object.keys(graph[node]);\n\n    for (j = 0, jl = graphNodeItems.length; j < jl; ++j) {\n      group = graph[node][graphNodeItems[j]];\n      groups[group] = groups[group] || [];\n\n      for (var k = 0, kl = groups[group].length; k < kl; ++k) {\n        expandedGroups.push(groups[group][k]);\n      }\n    }\n\n    graph[node] = expandedGroups;\n  } // Merge intermediary graph using graphAfters into final graph\n\n\n  var afterNodes = Object.keys(graphAfters);\n\n  for (i = 0, il = afterNodes.length; i < il; ++i) {\n    group = afterNodes[i];\n\n    if (groups[group]) {\n      for (j = 0, jl = groups[group].length; j < jl; ++j) {\n        node = groups[group][j];\n        graph[node] = graph[node].concat(graphAfters[group]);\n      }\n    }\n  } // Compile ancestors\n\n\n  var children;\n  var ancestors = {};\n  graphNodes = Object.keys(graph);\n\n  for (i = 0, il = graphNodes.length; i < il; ++i) {\n    node = graphNodes[i];\n    children = graph[node];\n\n    for (j = 0, jl = children.length; j < jl; ++j) {\n      ancestors[children[j]] = (ancestors[children[j]] || []).concat(node);\n    }\n  } // Topo sort\n\n\n  var visited = {};\n  var sorted = [];\n\n  for (i = 0, il = this._items.length; i < il; ++i) {\n    var next = i;\n\n    if (ancestors[i]) {\n      next = null;\n\n      for (j = 0, jl = this._items.length; j < jl; ++j) {\n        if (visited[j] === true) {\n          continue;\n        }\n\n        if (!ancestors[j]) {\n          ancestors[j] = [];\n        }\n\n        var shouldSeeCount = ancestors[j].length;\n        var seenCount = 0;\n\n        for (var l = 0, ll = shouldSeeCount; l < ll; ++l) {\n          if (sorted.indexOf(ancestors[j][l]) >= 0) {\n            ++seenCount;\n          }\n        }\n\n        if (seenCount === shouldSeeCount) {\n          next = j;\n          break;\n        }\n      }\n    }\n\n    if (next !== null) {\n      next = next.toString(); // Normalize to string TODO: replace with seq\n\n      visited[next] = true;\n      sorted.push(next);\n    }\n  }\n\n  if (sorted.length !== this._items.length) {\n    return new Error('Invalid dependencies');\n  }\n\n  var seqIndex = {};\n\n  for (i = 0, il = this._items.length; i < il; ++i) {\n    item = this._items[i];\n    seqIndex[item.seq] = item;\n  }\n\n  var sortedNodes = [];\n  this._items = sorted.map(function (value) {\n    var sortedItem = seqIndex[value];\n    sortedNodes.push(sortedItem.node);\n    return sortedItem;\n  });\n  this.nodes = sortedNodes;\n};","map":null,"metadata":{},"sourceType":"script"}