{"ast":null,"code":"// Load modules\nvar Hoek = require('hoek');\n\nvar Ref = require('./ref');\n\nvar Errors = require('./errors');\n\nvar Alternatives = null; // Delay-loaded to prevent circular dependencies\n\nvar Cast = null; // Declare internals\n\nvar internals = {};\ninternals.defaults = {\n  abortEarly: true,\n  convert: true,\n  allowUnknown: false,\n  skipFunctions: false,\n  stripUnknown: false,\n  language: {},\n  presence: 'optional',\n  raw: false,\n  strip: false,\n  noDefaults: false // context: null\n\n};\n\ninternals.checkOptions = function (options) {\n  var optionType = {\n    abortEarly: 'boolean',\n    convert: 'boolean',\n    allowUnknown: 'boolean',\n    skipFunctions: 'boolean',\n    stripUnknown: 'boolean',\n    language: 'object',\n    presence: ['string', 'required', 'optional', 'forbidden', 'ignore'],\n    raw: 'boolean',\n    context: 'object',\n    strip: 'boolean',\n    noDefaults: 'boolean'\n  };\n  var keys = Object.keys(options);\n\n  for (var k = 0, kl = keys.length; k < kl; ++k) {\n    var key = keys[k];\n    var opt = optionType[key];\n    var type = opt;\n    var values = null;\n\n    if (Array.isArray(opt)) {\n      type = opt[0];\n      values = opt.slice(1);\n    }\n\n    Hoek.assert(type, 'unknown key ' + key);\n    Hoek.assert(typeof options[key] === type, key + ' should be of type ' + type);\n\n    if (values) {\n      Hoek.assert(values.indexOf(options[key]) >= 0, key + ' should be one of ' + values.join(', '));\n    }\n  }\n};\n\nmodule.exports = internals.Any = function () {\n  Cast = Cast || require('./cast');\n  this.isJoi = true;\n  this._type = 'any';\n  this._settings = null;\n  this._valids = new internals.Set();\n  this._invalids = new internals.Set();\n  this._tests = [];\n  this._refs = [];\n  this._flags = {\n    /*\n    presence: 'optional',                   // optional, required, forbidden, ignore\n    allowOnly: false,\n    allowUnknown: undefined,\n    default: undefined,\n    forbidden: false,\n    encoding: undefined,\n    insensitive: false,\n    trim: false,\n    case: undefined,                        // upper, lower\n    empty: undefined,\n    func: false\n    */\n  };\n  this._description = null;\n  this._unit = null;\n  this._notes = [];\n  this._tags = [];\n  this._examples = [];\n  this._meta = [];\n  this._inner = {}; // Hash of arrays of immutable objects\n};\n\ninternals.Any.prototype.isImmutable = true; // Prevents Hoek from deep cloning schema objects\n\ninternals.Any.prototype.clone = function () {\n  var obj = Object.create(Object.getPrototypeOf(this));\n  obj.isJoi = true;\n  obj._type = this._type;\n  obj._settings = internals.concatSettings(this._settings);\n  obj._valids = Hoek.clone(this._valids);\n  obj._invalids = Hoek.clone(this._invalids);\n  obj._tests = this._tests.slice();\n  obj._refs = this._refs.slice();\n  obj._flags = Hoek.clone(this._flags);\n  obj._description = this._description;\n  obj._unit = this._unit;\n  obj._notes = this._notes.slice();\n  obj._tags = this._tags.slice();\n  obj._examples = this._examples.slice();\n  obj._meta = this._meta.slice();\n  obj._inner = {};\n  var inners = Object.keys(this._inner);\n\n  for (var i = 0, il = inners.length; i < il; ++i) {\n    var key = inners[i];\n    obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\n  }\n\n  return obj;\n};\n\ninternals.Any.prototype.concat = function (schema) {\n  Hoek.assert(schema && schema.isJoi, 'Invalid schema object');\n  Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\n  var obj = this.clone();\n\n  if (this._type === 'any' && schema._type !== 'any') {\n    // Reset values as if we were \"this\"\n    var tmpObj = schema.clone();\n    var keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit', '_notes', '_tags', '_examples', '_meta', '_inner'];\n\n    for (var j = 0, jl = keysToRestore.length; j < jl; ++j) {\n      tmpObj[keysToRestore[j]] = obj[keysToRestore[j]];\n    }\n\n    obj = tmpObj;\n  }\n\n  obj._settings = obj._settings ? internals.concatSettings(obj._settings, schema._settings) : schema._settings;\n\n  obj._valids.merge(schema._valids, schema._invalids);\n\n  obj._invalids.merge(schema._invalids, schema._valids);\n\n  obj._tests = obj._tests.concat(schema._tests);\n  obj._refs = obj._refs.concat(schema._refs);\n  Hoek.merge(obj._flags, schema._flags);\n  obj._description = schema._description || obj._description;\n  obj._unit = schema._unit || obj._unit;\n  obj._notes = obj._notes.concat(schema._notes);\n  obj._tags = obj._tags.concat(schema._tags);\n  obj._examples = obj._examples.concat(schema._examples);\n  obj._meta = obj._meta.concat(schema._meta);\n  var inners = Object.keys(schema._inner);\n  var isObject = obj._type === 'object';\n\n  for (var i = 0, il = inners.length; i < il; ++i) {\n    var key = inners[i];\n    var source = schema._inner[key];\n\n    if (source) {\n      var target = obj._inner[key];\n\n      if (target) {\n        if (isObject && key === 'children') {\n          var keys = {};\n\n          for (var k = 0, kl = target.length; k < kl; ++k) {\n            keys[target[k].key] = k;\n          }\n\n          for (k = 0, kl = source.length; k < kl; ++k) {\n            var sourceKey = source[k].key;\n\n            if (keys[sourceKey] >= 0) {\n              target[keys[sourceKey]] = {\n                key: sourceKey,\n                schema: target[keys[sourceKey]].schema.concat(source[k].schema)\n              };\n            } else {\n              target.push(source[k]);\n            }\n          }\n        } else {\n          obj._inner[key] = obj._inner[key].concat(source);\n        }\n      } else {\n        obj._inner[key] = source.slice();\n      }\n    }\n  }\n\n  return obj;\n};\n\ninternals.Any.prototype._test = function (name, arg, func) {\n  Hoek.assert(!this._flags.allowOnly, 'Cannot define rules when valid values specified');\n  var obj = this.clone();\n\n  obj._tests.push({\n    func: func,\n    name: name,\n    arg: arg\n  });\n\n  return obj;\n};\n\ninternals.Any.prototype.options = function (options) {\n  Hoek.assert(!options.context, 'Cannot override context');\n  internals.checkOptions(options);\n  var obj = this.clone();\n  obj._settings = internals.concatSettings(obj._settings, options);\n  return obj;\n};\n\ninternals.Any.prototype.strict = function (isStrict) {\n  var obj = this.clone();\n  obj._settings = obj._settings || {};\n  obj._settings.convert = isStrict === undefined ? false : !isStrict;\n  return obj;\n};\n\ninternals.Any.prototype.raw = function (isRaw) {\n  var obj = this.clone();\n  obj._settings = obj._settings || {};\n  obj._settings.raw = isRaw === undefined ? true : isRaw;\n  return obj;\n};\n\ninternals.Any.prototype._allow = function () {\n  var values = Hoek.flatten(Array.prototype.slice.call(arguments));\n\n  for (var i = 0, il = values.length; i < il; ++i) {\n    var value = values[i];\n    Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n\n    this._invalids.remove(value);\n\n    this._valids.add(value, this._refs);\n  }\n};\n\ninternals.Any.prototype.allow = function () {\n  var obj = this.clone();\n\n  obj._allow.apply(obj, arguments);\n\n  return obj;\n};\n\ninternals.Any.prototype.valid = internals.Any.prototype.only = internals.Any.prototype.equal = function () {\n  Hoek.assert(!this._tests.length, 'Cannot set valid values when rules specified');\n  var obj = this.allow.apply(this, arguments);\n  obj._flags.allowOnly = true;\n  return obj;\n};\n\ninternals.Any.prototype.invalid = internals.Any.prototype.disallow = internals.Any.prototype.not = function (value) {\n  var obj = this.clone();\n  var values = Hoek.flatten(Array.prototype.slice.call(arguments));\n\n  for (var i = 0, il = values.length; i < il; ++i) {\n    value = values[i];\n    Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n\n    obj._valids.remove(value);\n\n    obj._invalids.add(value, this._refs);\n  }\n\n  return obj;\n};\n\ninternals.Any.prototype.required = internals.Any.prototype.exist = function () {\n  var obj = this.clone();\n  obj._flags.presence = 'required';\n  return obj;\n};\n\ninternals.Any.prototype.optional = function () {\n  var obj = this.clone();\n  obj._flags.presence = 'optional';\n  return obj;\n};\n\ninternals.Any.prototype.forbidden = function () {\n  var obj = this.clone();\n  obj._flags.presence = 'forbidden';\n  return obj;\n};\n\ninternals.Any.prototype.strip = function () {\n  var obj = this.clone();\n  obj._flags.strip = true;\n  return obj;\n};\n\ninternals.Any.prototype.applyFunctionToChildren = function (children, fn, args, root) {\n  children = [].concat(children);\n\n  if (children.length !== 1 || children[0] !== '') {\n    root = root ? root + '.' : '';\n    var extraChildren = (children[0] === '' ? children.slice(1) : children).map(function (child) {\n      return root + child;\n    });\n    throw new Error('unknown key(s) ' + extraChildren.join(', '));\n  }\n\n  return this[fn].apply(this, args);\n};\n\ninternals.Any.prototype.default = function (value, description) {\n  if (typeof value === 'function' && !Ref.isRef(value)) {\n    if (!value.description && description) {\n      value.description = description;\n    }\n\n    if (!this._flags.func) {\n      Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\n    }\n  }\n\n  var obj = this.clone();\n  obj._flags.default = value;\n  Ref.push(obj._refs, value);\n  return obj;\n};\n\ninternals.Any.prototype.empty = function (schema) {\n  var obj;\n\n  if (schema === undefined) {\n    obj = this.clone();\n    obj._flags.empty = undefined;\n  } else {\n    schema = Cast.schema(schema);\n    obj = this.clone();\n    obj._flags.empty = schema;\n  }\n\n  return obj;\n};\n\ninternals.Any.prototype.when = function (ref, options) {\n  Hoek.assert(options && typeof options === 'object', 'Invalid options');\n  Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n  var then = options.then ? this.concat(Cast.schema(options.then)) : this;\n  var otherwise = options.otherwise ? this.concat(Cast.schema(options.otherwise)) : this;\n  Alternatives = Alternatives || require('./alternatives');\n  var obj = Alternatives.when(ref, {\n    is: options.is,\n    then: then,\n    otherwise: otherwise\n  });\n  obj._flags.presence = 'ignore';\n  return obj;\n};\n\ninternals.Any.prototype.description = function (desc) {\n  Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\n  var obj = this.clone();\n  obj._description = desc;\n  return obj;\n};\n\ninternals.Any.prototype.notes = function (notes) {\n  Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\n  var obj = this.clone();\n  obj._notes = obj._notes.concat(notes);\n  return obj;\n};\n\ninternals.Any.prototype.tags = function (tags) {\n  Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\n  var obj = this.clone();\n  obj._tags = obj._tags.concat(tags);\n  return obj;\n};\n\ninternals.Any.prototype.meta = function (meta) {\n  Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\n  var obj = this.clone();\n  obj._meta = obj._meta.concat(meta);\n  return obj;\n};\n\ninternals.Any.prototype.example = function (value) {\n  Hoek.assert(arguments.length, 'Missing example');\n\n  var result = this._validate(value, null, internals.defaults);\n\n  Hoek.assert(!result.errors, 'Bad example:', result.errors && Errors.process(result.errors, value));\n  var obj = this.clone();\n  obj._examples = obj._examples.concat(value);\n  return obj;\n};\n\ninternals.Any.prototype.unit = function (name) {\n  Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\n  var obj = this.clone();\n  obj._unit = name;\n  return obj;\n};\n\ninternals._try = function (fn, arg) {\n  var err;\n  var result;\n\n  try {\n    result = fn.call(null, arg);\n  } catch (e) {\n    err = e;\n  }\n\n  return {\n    value: result,\n    error: err\n  };\n};\n\ninternals.Any.prototype._validate = function (value, state, options, reference) {\n  var self = this;\n  var originalValue = value; // Setup state and settings\n\n  state = state || {\n    key: '',\n    path: '',\n    parent: null,\n    reference: reference\n  };\n\n  if (this._settings) {\n    options = internals.concatSettings(options, this._settings);\n  }\n\n  var errors = [];\n\n  var finish = function finish() {\n    var finalValue;\n\n    if (!self._flags.strip) {\n      if (value !== undefined) {\n        finalValue = options.raw ? originalValue : value;\n      } else if (options.noDefaults) {\n        finalValue = originalValue;\n      } else if (Ref.isRef(self._flags.default)) {\n        finalValue = self._flags.default(state.parent, options);\n      } else if (typeof self._flags.default === 'function' && !(self._flags.func && !self._flags.default.description)) {\n        var arg;\n\n        if (state.parent !== null && self._flags.default.length > 0) {\n          arg = Hoek.clone(state.parent);\n        }\n\n        var defaultValue = internals._try(self._flags.default, arg);\n\n        finalValue = defaultValue.value;\n\n        if (defaultValue.error) {\n          errors.push(Errors.create('any.default', defaultValue.error, state, options));\n        }\n      } else {\n        finalValue = Hoek.clone(self._flags.default);\n      }\n    }\n\n    return {\n      value: finalValue,\n      errors: errors.length ? errors : null\n    };\n  }; // Check presence requirements\n\n\n  var presence = this._flags.presence || options.presence;\n\n  if (presence === 'optional') {\n    if (value === undefined) {\n      var isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\n\n      if (isDeepDefault && this._type === 'object') {\n        value = {};\n      } else {\n        return finish();\n      }\n    }\n  } else if (presence === 'required' && value === undefined) {\n    errors.push(Errors.create('any.required', null, state, options));\n    return finish();\n  } else if (presence === 'forbidden') {\n    if (value === undefined) {\n      return finish();\n    }\n\n    errors.push(Errors.create('any.unknown', null, state, options));\n    return finish();\n  }\n\n  if (this._flags.empty && !this._flags.empty._validate(value, null, internals.defaults).errors) {\n    value = undefined;\n    return finish();\n  } // Check allowed and denied values using the original value\n\n\n  if (this._valids.has(value, state, options, this._flags.insensitive)) {\n    return finish();\n  }\n\n  if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n    errors.push(Errors.create(value === '' ? 'any.empty' : 'any.invalid', null, state, options));\n\n    if (options.abortEarly || value === undefined) {\n      // No reason to keep validating missing value\n      return finish();\n    }\n  } // Convert value and validate type\n\n\n  if (this._base) {\n    var base = this._base.call(this, value, state, options);\n\n    if (base.errors) {\n      value = base.value;\n      errors = errors.concat(base.errors);\n      return finish(); // Base error always aborts early\n    }\n\n    if (base.value !== value) {\n      value = base.value; // Check allowed and denied values using the converted value\n\n      if (this._valids.has(value, state, options, this._flags.insensitive)) {\n        return finish();\n      }\n\n      if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n        errors.push(Errors.create('any.invalid', null, state, options));\n\n        if (options.abortEarly) {\n          return finish();\n        }\n      }\n    }\n  } // Required values did not match\n\n\n  if (this._flags.allowOnly) {\n    errors.push(Errors.create('any.allowOnly', {\n      valids: this._valids.values({\n        stripUndefined: true\n      })\n    }, state, options));\n\n    if (options.abortEarly) {\n      return finish();\n    }\n  } // Helper.validate tests\n\n\n  for (var i = 0, il = this._tests.length; i < il; ++i) {\n    var test = this._tests[i];\n    var err = test.func.call(this, value, state, options);\n\n    if (err) {\n      errors.push(err);\n\n      if (options.abortEarly) {\n        return finish();\n      }\n    }\n  }\n\n  return finish();\n};\n\ninternals.Any.prototype._validateWithOptions = function (value, options, callback) {\n  if (options) {\n    internals.checkOptions(options);\n  }\n\n  var settings = internals.concatSettings(internals.defaults, options);\n\n  var result = this._validate(value, null, settings);\n\n  var errors = Errors.process(result.errors, value);\n\n  if (callback) {\n    return callback(errors, result.value);\n  }\n\n  return {\n    error: errors,\n    value: result.value\n  };\n};\n\ninternals.Any.prototype.validate = function (value, callback) {\n  var result = this._validate(value, null, internals.defaults);\n\n  var errors = Errors.process(result.errors, value);\n\n  if (callback) {\n    return callback(errors, result.value);\n  }\n\n  return {\n    error: errors,\n    value: result.value\n  };\n};\n\ninternals.Any.prototype.describe = function () {\n  var description = {\n    type: this._type\n  };\n  var flags = Object.keys(this._flags);\n\n  if (flags.length) {\n    if (this._flags.empty) {\n      description.flags = {};\n\n      for (var f = 0, fl = flags.length; f < fl; ++f) {\n        var flag = flags[f];\n        description.flags[flag] = flag === 'empty' ? this._flags[flag].describe() : this._flags[flag];\n      }\n    } else {\n      description.flags = this._flags;\n    }\n  }\n\n  if (this._description) {\n    description.description = this._description;\n  }\n\n  if (this._notes.length) {\n    description.notes = this._notes;\n  }\n\n  if (this._tags.length) {\n    description.tags = this._tags;\n  }\n\n  if (this._meta.length) {\n    description.meta = this._meta;\n  }\n\n  if (this._examples.length) {\n    description.examples = this._examples;\n  }\n\n  if (this._unit) {\n    description.unit = this._unit;\n  }\n\n  var valids = this._valids.values();\n\n  if (valids.length) {\n    description.valids = valids;\n  }\n\n  var invalids = this._invalids.values();\n\n  if (invalids.length) {\n    description.invalids = invalids;\n  }\n\n  description.rules = [];\n\n  for (var i = 0, il = this._tests.length; i < il; ++i) {\n    var validator = this._tests[i];\n    var item = {\n      name: validator.name\n    };\n\n    if (validator.arg !== void 0) {\n      item.arg = validator.arg;\n    }\n\n    description.rules.push(item);\n  }\n\n  if (!description.rules.length) {\n    delete description.rules;\n  }\n\n  var label = Hoek.reach(this._settings, 'language.label');\n\n  if (label) {\n    description.label = label;\n  }\n\n  return description;\n};\n\ninternals.Any.prototype.label = function (name) {\n  Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\n  var obj = this.clone();\n  var options = {\n    language: {\n      label: name\n    }\n  }; // If language.label is set, it should override this label\n\n  obj._settings = internals.concatSettings(options, obj._settings);\n  return obj;\n}; // Set\n\n\ninternals.Set = function () {\n  this._set = [];\n};\n\ninternals.Set.prototype.add = function (value, refs) {\n  Hoek.assert(value === null || value === undefined || value instanceof Date || Buffer.isBuffer(value) || Ref.isRef(value) || typeof value !== 'function' && typeof value !== 'object', 'Value cannot be an object or function');\n\n  if (typeof value !== 'function' && this.has(value, null, null, false)) {\n    return;\n  }\n\n  Ref.push(refs, value);\n\n  this._set.push(value);\n};\n\ninternals.Set.prototype.merge = function (add, remove) {\n  for (var i = 0, il = add._set.length; i < il; ++i) {\n    this.add(add._set[i]);\n  }\n\n  for (i = 0, il = remove._set.length; i < il; ++i) {\n    this.remove(remove._set[i]);\n  }\n};\n\ninternals.Set.prototype.remove = function (value) {\n  this._set = this._set.filter(function (item) {\n    return value !== item;\n  });\n};\n\ninternals.Set.prototype.has = function (value, state, options, insensitive) {\n  for (var i = 0, il = this._set.length; i < il; ++i) {\n    var items = this._set[i];\n\n    if (Ref.isRef(items)) {\n      items = items(state.reference || state.parent, options);\n    }\n\n    if (!Array.isArray(items)) {\n      items = [items];\n    }\n\n    for (var j = 0, jl = items.length; j < jl; ++j) {\n      var item = items[j];\n\n      if (typeof value !== typeof item) {\n        continue;\n      }\n\n      if (value === item || value instanceof Date && item instanceof Date && value.getTime() === item.getTime() || insensitive && typeof value === 'string' && value.toLowerCase() === item.toLowerCase() || Buffer.isBuffer(value) && Buffer.isBuffer(item) && value.length === item.length && value.toString('binary') === item.toString('binary')) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\ninternals.Set.prototype.values = function (options) {\n  if (options && options.stripUndefined) {\n    var values = [];\n\n    for (var i = 0, il = this._set.length; i < il; ++i) {\n      var item = this._set[i];\n\n      if (item !== undefined) {\n        values.push(item);\n      }\n    }\n\n    return values;\n  }\n\n  return this._set.slice();\n};\n\ninternals.concatSettings = function (target, source) {\n  // Used to avoid cloning context\n  if (!target && !source) {\n    return null;\n  }\n\n  var key,\n      obj = {};\n\n  if (target) {\n    var tKeys = Object.keys(target);\n\n    for (var i = 0, il = tKeys.length; i < il; ++i) {\n      key = tKeys[i];\n      obj[key] = target[key];\n    }\n  }\n\n  if (source) {\n    var sKeys = Object.keys(source);\n\n    for (var j = 0, jl = sKeys.length; j < jl; ++j) {\n      key = sKeys[j];\n\n      if (key !== 'language' || !obj.hasOwnProperty(key)) {\n        obj[key] = source[key];\n      } else {\n        obj[key] = Hoek.applyToDefaults(obj[key], source[key]);\n      }\n    }\n  }\n\n  return obj;\n};","map":null,"metadata":{},"sourceType":"script"}